# book-microservice-pattern
`마이크로서비스 패턴, 길벗` 도서 요약 정리입니다.   
`FTGO`라는 `음식배달` 서비스를 예제로 합니다.    
기존에는 `WAR`파일로 구성된 `모놀리스`로 개발되었으나 서비스가 커지면서 많은 문제가 발생합니다.  


#
## 3. 프로세스 간 통신
- 마이크로서비스 아키텐트는 여러 개의 서비스로 구성하며 서비스 인스턴스는 여러 머신에서 실행되는 프로세스 형태이므로 반드시 IPC를 통해 상호 작용해야 한다.  
(IPC: 프로세스간 통신)  
- IPC기술은 JSON을 주고받는 REST가 대세이지만 메시징 등 다양한 IPC 옵션을 고려해야 한다. 


#
#### 클라이언트/서비스 상호 작용 스타일 분류
- 일대다 여부
  - one to one: 각 요청을 한 서비스가 처리
  - one to many: 각 요청을 여러 서비스가 협동하여 처리    

- 비동기 여부  
  - synchronous: 클라이언트는 서비스가 제시간에 응답하리라 기대하고 블로킹할 수 있음
  - asynchronous: 응답은 즉시 전동되지 않아도 됨, 블로킹 하지 않음

- 일대일 상호 작용 종류
  - 요청/응답
  - 비동기 요청/응답
  - 단방향 알림

- 일대다 상호 작용 종류
  - 발행/구독
  - 발행/비동기 응답

#
#### API 정의
한 언어로 작성되는 모놀리식과 달리 마이크로서비스는 API가 프로그래밍 언어의 일부가 아니기 때문에 함께 컴파일 되지 않으며 서로 호환되지 않는 API에 맞물리더라도 컴파일 되지 않으며 조용히 런타임에 실패한 것이다.  
따라서 서비스 API를 `IDL`(Interface Definition Language)로 정확하게 정의해야 한다.  


API는 어떤 IPC를 사용하느냐에 따라 결정되는데, 메시징은 메시지채널, 메시지타입, 메시지 포멧으로 정의된다.  
HTTP로 통신하는 API는 URI, HTTP 동사, 용청/응답 포멧으로 구성된다.   


#
#### API 발전시키기
API는 새 기능을 ㅜ가하거나 기존 기능을 변경/삭제하는 등 계속 변한다.  
모놀로식의 경우 그리 어렵지 않지만 서로 다른 팀에서 개발한 경우가 대부분이라 변경하기가 쉽지 않다.  
따라서 전략을 잘 세워야 한다.   
  
- 시멘틱 버저닝
  - Semvers(Sementic Versioning Specification, https://semver.org/)는 버저닝에 대한 유용한 지침서이다.  
  - MAJOR, MINOR, PATCH 세 파트로 버전 번호를 구성하고 규칙에 따라 증가시킨다. 
  - MAJOR: 하위 호환되지 않는 변경분 적용시
  - MINOR: 하위 호환되는 변경분 적용시
  - PATCH: 하휘 호환되는 오류 수정시

#
#### 메시지 포멧
IPC의 핵심은 메시지 교환이다.  
범언어적 메시키 포멧을 선택하는 것이 중요하다.  
크게 텍스트, 이진 포맷으로 분류된다.  
- 텍스트 메시지 포맷
  - JSON, XML
  - 메시키 컨슈머는 관심있는 값만 골라쓰면 되므로 하위 호환성이 쉽게 보장된다. 
  - 덩치가 큰 메시지는 오버헤드를 고려하여 이진 포멧을 고려할 것
- 이진 포멧
  - 프로토콜 버퍼(https://developers.google.com/protocol-buffers/docs/overview), 아브로가 유명하다


#
#### REST 
예를 들어 특정 주문과 주문한 소비자를 REST로 조회하는 클라이언트가 있다고 하면,  
순수 REST API라면 적어도 2회 요청이 필요하다.  
시나리오가 복잡해지면 왕복 횟수가 증가하고 지연 시간이 급증해질 것이다.  


해결하는 한 가지 방법은 다 함께 조회되도록 API가 허락하는 것인데  
(ex: GET /orders/order-id-12343?expand=consumer)  
역시 시나리오가 복잡해지면 효율이 떨어지고 구현시간도 늘어나게 될 것이다.  
이런 까닭에 효율적으로 데이터를 조회할 수 있게 설계된 `GraphQL`이나 `Netflix Falcon` 등 대체 API기술이 각광받기 시작했다.  

 
또한 비즈니스 객체에 수행할 작업을 HTTP 동사에 어떻게 매핑해야 할지도 고민거리.  
한가지 해결 방법은 리소스의 특정 부위를 업데이트하는 하위 리소스를 정의하는 것.  
(주문취소 POST /orders/{orderId}/cancel, 주문 변경 POST /orders/{orderId}/revise)  
`gRPC`같은 REST 대체 기술이 점점 인기를 끌고 있다.


#
#### gRPC
HTTP는 한정된 동사만 지원하기 때문에 등장한 기술이 `gRPC`이다.  
다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크이다.  
클라이언트/서버는 `프로토콜 버퍼` 포멧의 이진 메시지를 `HTTP/2`를 통해 교환한다.  

예제)  
```
service OrderService {
    createOrder(CreateOrderRequest) return (CreateOrderReply) {}
    cancelOrder(CancelOrderRequest) return (CancelOrderReply) {}
    reviseOrder(ReviseOrderRequest) return (ReviseOrderReply) {}
    ...
}

message CreateOrderRequest {
    int64 restaurantId = 1;
    int64 consumerId = 2;
    repeated LineItem lineItems = 3;
    ...
}

message LineItem {
    string menuItemId = 1;
    int32 quantity = 2;
}

message CreateOrderReply {
    int64 orderId = 1;
}
```   
- 장점
  - 다양한 업데이트 작업이 포함된 API 설계 용이
  - 큰 메시지 교환시 효율적
  - 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식 모두 가능
  - 다양한 언어 가능
- 단점
  - 자바스크립트 클라이언트가 하는일이 매우 많음
  - 구형 방화벽은 HTTP/2를 지원하지 않음

`gRPC`는 `REST`를 대체할 만한 방안이지만 동기 통신하는 메커니즘이라서 부분 실패 문제는 풀어야하는 숙제이다.   

#
#### 부분실패 처리: circuit breaker
분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패할 가능성이 항상 존재한다.  
블로킹 되기 때문에 부분 실패가 전체 시스템을 중단시킬 수도 있다.  
따라서 부분 실패가 전체 어플리케이션에 전파되지 않도록 해야 한다.  
- 무응답 원격 서비스 처리를 위한 OrderServiceProxy 같은 RPI 프록시 설계
  - 타임아웃
  - 미처리 요청 개수 제한
  - circuit breaker pattern, 에러율의 임계치 초과시 그 이후 시도는 바로 실패 처리
    - `netflix Hystrix`, Polly(.net) 
- 불능 서비스 복구
  - 어떻게 복구할지는 상황에 따라 
  - 에러 반환하기
  - 미리 정해진 기본값이나 캐시된 응답 등 대체 값을 반한하기
 
 
#
#### 서비스 디스커버리 
REST API가 있는 어떤 서비스를 호출할 때, 그 서비스 인스턴스의 네트워크 위치를 알고 있어야 요청이 가능하다.  
클라우드 기반의 마이크로서비스 어플리케이션은 그 위치가 동적이라 식별하는 게 간단하지 않다.  
또한 서비스 인스턴스가 자동 확장 되고, 실패, 업그레이드 등 계속 달라지므로 서비스 디스커버리가 필요하다.  


서비스 인스턴스의 네트워크 위치를 DB화 한 서비스 레지스트리.  
서비스 인스턴스가 시작/종료될 때마다 서비스 레지스트리가 업데이트 된다.  


- 애플리케이션 수준 디스커버리 패턴
  - `Eureka`
  - 사용하는 언어에 맞는 서비스 디스커버리 라이브러리가 필요한 단점. 
- 플랫폼에 내장된 서비스 디스커버리 패턴
  - `도커`, `쿠버네티스` 등 최신 배포 플랫폼에는 대부분 서비스 레지스트리, 서비스 디스커버리 매커니즘이 탑재되어 있다.  
  - 쿠버네티스에 기반한 디스커버리는 오직 쿠버네티스로 배포한 서비스에만 적용되는 단점. 
  - 개발 언어 상관없이 모든 클라이언트/서비스에 적용 가능


#
#### 비동기 메시징 패턴
메시징은 서비스가 메시지를 서로 비동기적으로 주고받는 통신 방식이다.  
서비스 간 중개 역할을 하는 `메시지 브로커`를 사용하는데 서비스가 직접 서로 통신하는 `브로커리스` 아키텍처도 있다.

#
##### 메시징
메시지는 header, body로 구성된다.  
헤더는 송신된 데이터에 관한 메타데이터에 해당하는 키/값으로 구성.  
그 밖에도 송신자, 인프라에서 생성된 메시지 ID, 응답이 출력될 메시지 채널을 가리키는 반환 주소 등이 있다.  
본문은 실제로 송신할 텍스트 또는 이진 포맷의 데이터.  

- 메시지 종류
  - 문서(document): 데이터만 포함된 제네릭한 메시지. 
  - 커맨드: RPC 요청과 동등한 메시지. 
  - 이벤트: 송신자에게 어떤 사건이 발생했음을 알리는 메시지. 대부분 Order, Customer 같은 도메인 객체의 상태 변화를 나타내는 도메인 이벤트


- 메시지 채널
  - 메시지를 채널을 통해 교환된다.  
  - 채널 종류
    - 점대점(point to point): 채널을 읽는 컨슈머 중 딱 하나만 지정하여 메시지를 전달. 예: 커맨드 메시지
    - publish/subscribe: 같은 채널을 바라보는 모든 컨슈머에 메시지를 전달. 예: 이벤트 메시지
    

#
#### 메시지 브로커
   
   

  
  



 






















 




