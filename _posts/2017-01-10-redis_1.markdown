---
layout: post
title:  "redis #1"
date:   2017-01-09 17:10:53 +0900
categories: redis
---


## Redis 핵심정리 책 Study

.

# 시작하기

.

REmote Dictionary Server  
레디스는 고성능 `키-값 데이터 저장소인 NoSQL`이다.  
문자열, 해시, 리스트, 셋, 정렬된 셋, 비트맵, 하이퍼로그로그와 같은 강력한 데이터 타입 때문에 데이터 구조 서버라고도 불린다.  

.

레디스는 기본적으로 `모든 데이터를 메모리에 저장`하기 때문에 읽기와 쓰기가 매우 빠르다.  
(디스크에도 저장할 수 있다.)

.

영속성  

* 바이너리 스냅샷으로 생성 -> **스냅샷**  

* 시간에 따른 커맨드를 순서대로 저장, 파일로 생성 -> **저널링**   

.

key expiration, transaction, publish/subscribe 기능 설정이 가능하다.

.

루아(lua) script 기능을 제공한다.

.

Redis 문서는 http://redis.io 에서 볼 수 있다.

.

**설치**
{% highlight ruby %}
$ curl -O http://download.redis.io/releases/redis-3.0.2.tar.gz
$ tar xzvf redis-3.0.2.tar.gz
$ cd redis-3.0.2
$ sudo make install
{% endhighlight %}

.  

**Hello Redis with Node**  
Redis는 여러 실행파일을 제공하는데, 우선 redis-server와 redis-cli를 살펴본다.  

* redis-server : 실제 데이터 저장소  

* redis-cli : command line interface

.

레디스는 기본적으로 6379 포트를 바인드하고, 독립 실행형 모드로 실행한다.

.

다음은 redis-cli를 사용해 redis-server에 접속하는 방법이다.
{% highlight ruby %}
$ redis-cli
> SET philosopher "socrates"  \\ 키 생성
OK
> GET philosopher  \\ 키값 읽기
"socrates"
{% endhighlight %}

.

패턴과 일치하는 키 리턴
{% highlight ruby %}
> KEYS [pattern]
{% endhighlight %}

.

node를 사용. redis 라이브러리를 설치한다.
{% highlight ruby %}
$ cd redis-essentials
$ npm install redis
{% endhighlight %}

.

hello.js  
{% highlight ruby %}
var redis = require("redis");
var client = redis.createClient();
client.set("my_key", "Hello World");
client.get("my_key", redis.print);
client.quit();  

$ node hello.js
{% endhighlight %}

.

**레디스 데이터 타입**  
문자열  

* 많은 커맨드를 가지고 여러 목적으로 사용된다.  

* 텍스트(XML, JSON, HTML etc), 정수, 부동소수점, binary data(video, audio, image) 등이 저장된다.  

* 512MB 초과 X  

* 예제
  {% highlight ruby %}
  $ redis-cli
  > MSET first "First key value" second "Second key value"
  OK
  > EXPIRE first 10
  (Integer) 1
  > MGET first second
  "First key value"
  "Second key value"
  > TTL first
  (Integer) 3 // remaining seconds
  {% endhighlight %}

.

리스트  

* 간단한 콜렉션, 스택, 큐

* 연결리스트여서 추가 삭제 O(1), 접근 O(N)

* 리스트의 각 엘리먼트가 list-max-ziplist-value 보다 작고, 개수가 list-max-ziplist-entries 보다 작으면 인코드 될 수 있고, 메모리를 최적화 할 수 있다.

* 트위터에서 사용자의 최근 트윗 저장시 리스트를 사용하고 있다.

* 예제
{% highlight ruby %}
$ redis-cli
> LPUSH books "Clean Code"
(Integer) 1
> RPUSH books "Code Complete"
(Integer) 2
> LPUSH books "Peopleware"
(Integer) 3
> LLEN books
(Integer) 3
> LINDEX books 1
"Clean Code"
> LRANGE books 0 1
"Peopleware"
"Clean Code"
> LPOP books
"Peopleware"
> LPOP books
"Code Complete"
{% endhighlight %}

.

해시

* 문자열을 문자열로 매핑

* 메모리를 효율적으로 쓴다. 검색이 빠르다.

* hash-max-ziplist-entries, hash-max-ziplist-value 설정 기반

* 예제
{% highlight ruby %}
$ redis-cli
> HSET movie "title" "The Godfather"
(Integer) 1
> HMSET movie "year" 1972 "rating" 9.2 "watchers" 1000000
OK
> HINCRBY movie "watchers" 3
(integer) 1000003
> HGET movie "title"
"The Godfather"
> HMGET movie "title" "watchers"
"The Godfather"
"1000003"
> HDEL movie "watchers"
(integer) 1
> HGETALL movie
"title"
"The Godfather"
"year"
"1972"
"rating"
"9.2"
{% endhighlight %}

*  해시와 노드를 이용한 투표 시스템 예제
hash-voting-system.js
{% highlight ruby %}
var redis = require("redis");
var client = redis.createClient();

function saveLink(id, author, title, link) {
  client.hmset("link:" + id, "author", author, "title", title, "link", link, "score", 0);
}

function upVote(id) {
  client.hincrby("link:" + id, "score", 1);
}

function downVote(id) {
  client.hincrby("linke:" + id, "score", -1);
}

function showDetails(id) {
  client.hgetall("link:" + id, function(err, replies){
    console.log("Title:",replies['title']);
    console.log("Author:",replies['author']);
    console.log("Link:",replies['link']);
    console.log("Score:",replies['score']);  
  });
}

saveLink(123,"dayvson","My Github page", "https://github.com/dayvson");
upVote(123);
upVote(123);
saveLink(456,"hltbra","hltbar page", "https://github.com/hltbra");
upVote(456);
upVote(456);
downVote(456);

showDetails(123);
showDetails(456);

client.quit();
{% endhighlight %}

command
{% highlight ruby %}
$ node hash-voting-system.js
{% endhighlight %}


해시에 많은 필드가 존재하는 경우 HGETALL은 성능 이슈가 있을 수 있다. 이때는 HSCAN이 대안이 될 수 있다.
