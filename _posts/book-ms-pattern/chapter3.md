# book-microservice-pattern
`마이크로서비스 패턴, 길벗` 도서 요약 정리입니다.   
`FTGO`라는 `음식배달` 서비스를 예제로 합니다.    
기존에는 `WAR`파일로 구성된 `모놀리스`로 개발되었으나 서비스가 커지면서 많은 문제가 발생합니다.  


#
## 3. 프로세스 간 통신
- 마이크로서비스 아키텐트는 여러 개의 서비스로 구성하며 서비스 인스턴스는 여러 머신에서 실행되는 프로세스 형태이므로 반드시 IPC를 통해 상호 작용해야 한다.  
(IPC: 프로세스간 통신)  
- IPC기술은 JSON을 주고받는 REST가 대세이지만 메시징 등 다양한 IPC 옵션을 고려해야 한다. 


#
#### 클라이언트/서비스 상호 작용 스타일 분류
- 일대다 여부
  - one to one: 각 요청을 한 서비스가 처리
  - one to many: 각 요청을 여러 서비스가 협동하여 처리    

- 비동기 여부  
  - synchronous: 클라이언트는 서비스가 제시간에 응답하리라 기대하고 블로킹할 수 있음
  - asynchronous: 응답은 즉시 전동되지 않아도 됨, 블로킹 하지 않음

- 일대일 상호 작용 종류
  - 요청/응답
  - 비동기 요청/응답
  - 단방향 알림

- 일대다 상호 작용 종류
  - 발행/구독
  - 발행/비동기 응답

#
#### API 정의
한 언어로 작성되는 모놀리식과 달리 마이크로서비스는 API가 프로그래밍 언어의 일부가 아니기 때문에 함께 컴파일 되지 않으며 서로 호환되지 않는 API에 맞물리더라도 컴파일 되지 않으며 조용히 런타임에 실패한 것이다.  
따라서 서비스 API를 `IDL`(Interface Definition Language)로 정확하게 정의해야 한다.  


API는 어떤 IPC를 사용하느냐에 따라 결정되는데, 메시징은 메시지채널, 메시지타입, 메시지 포멧으로 정의된다.  
HTTP로 통신하는 API는 URI, HTTP 동사, 용청/응답 포멧으로 구성된다.   


#
#### API 발전시키기
API는 새 기능을 ㅜ가하거나 기존 기능을 변경/삭제하는 등 계속 변한다.  
모놀로식의 경우 그리 어렵지 않지만 서로 다른 팀에서 개발한 경우가 대부분이라 변경하기가 쉽지 않다.  
따라서 전략을 잘 세워야 한다.   
  
- 시멘틱 버저닝
  - Semvers(Sementic Versioning Specification, https://semver.org/)는 버저닝에 대한 유용한 지침서이다.  
  - MAJOR, MINOR, PATCH 세 파트로 버전 번호를 구성하고 규칙에 따라 증가시킨다. 
  - MAJOR: 하위 호환되지 않는 변경분 적용시
  - MINOR: 하위 호환되는 변경분 적용시
  - PATCH: 하휘 호환되는 오류 수정시

#
#### 메시지 포멧
IPC의 핵심은 메시지 교환이다.  
범언어적 메시키 포멧을 선택하는 것이 중요하다.  
크게 텍스트, 이진 포맷으로 분류된다.  
- 텍스트 메시지 포맷
  - JSON, XML
  - 메시키 컨슈머는 관심있는 값만 골라쓰면 되므로 하위 호환성이 쉽게 보장된다. 
  - 덩치가 큰 메시지는 오버헤드를 고려하여 이진 포멧을 고려할 것
- 이진 포멧
  - 프로토콜 버퍼(https://developers.google.com/protocol-buffers/docs/overview), 아브로가 유명하다


#
#### REST 
예를 들어 특정 주문과 주문한 소비자를 REST로 조회하는 클라이언트가 있다고 하면,  
순수 REST API라면 적어도 2회 요청이 필요하다.  
시나리오가 복잡해지면 왕복 횟수가 증가하고 지연 시간이 급증해질 것이다.  


해결하는 한 가지 방법은 다 함께 조회되도록 API가 허락하는 것인데  
(ex: GET /orders/order-id-12343?expand=consumer)  
역시 시나리오가 복잡해지면 효율이 떨어지고 구현시간도 늘어나게 될 것이다.  
이런 까닭에 효율적으로 데이터를 조회할 수 있게 설계된 `GraphQL`이나 `Netflix Falcon` 등 대체 API기술이 각광받기 시작했다.  

 
또한 비즈니스 객체에 수행할 작업을 HTTP 동사에 어떻게 매핑해야 할지도 고민거리.  
한가지 해결 방법은 리소스의 특정 부위를 업데이트하는 하위 리소스를 정의하는 것.  
(주문취소 POST /orders/{orderId}/cancel, 주문 변경 POST /orders/{orderId}/revise)  
`gRPC`같은 REST 대체 기술이 점점 인기를 끌고 있다.


#
#### gRPC
HTTP는 한정된 동사만 지원하기 때문에 등장한 기술이 `gRPC`이다.  
다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크이다.  
클라이언트/서버는 `프로토콜 버퍼` 포멧의 이진 메시지를 `HTTP/2`를 통해 교환한다.  

예제)  
```
service OrderService {
    createOrder(CreateOrderRequest) return (CreateOrderReply) {}
    cancelOrder(CancelOrderRequest) return (CancelOrderReply) {}
    reviseOrder(ReviseOrderRequest) return (ReviseOrderReply) {}
    ...
}

message CreateOrderRequest {
    int64 restaurantId = 1;
    int64 consumerId = 2;
    repeated LineItem lineItems = 3;
    ...
}

message LineItem {
    string menuItemId = 1;
    int32 quantity = 2;
}

message CreateOrderReply {
    int64 orderId = 1;
}
```   
- 장점
  - 다양한 업데이트 작업이 포함된 API 설계 용이
  - 큰 메시지 교환시 효율적
  - 양방향 스트리밍 덕분에 RPI, 메시징 두 가지 통신 방식 모두 가능
  - 다양한 언어 가능
- 단점
  - 자바스크립트 클라이언트가 하는일이 매우 많음
  - 구형 방화벽은 HTTP/2를 지원하지 않음

`gRPC`는 `REST`를 대체할 만한 방안이지만 동기 통신하는 메커니즘이라서 부분 실패 문제는 풀어야하는 숙제이다.   



#
#### 부분실패 처리: circuit breaker
분산 시스템은 서비스가 다른 서비스를 동기 호출할 때마다 부분 실패할 가능성이 항상 존재한다.  
블로킹 되기 때문에 부분 실패가 전체 시스템을 중단시킬 수도 있다.  
따라서 부분 실패가 전체 어플리케이션에 전파되지 않도록 해야 한다.  
- 무응답 원격 서비스 처리를 위한 OrderServiceProxy 같은 RPI 프록시 설계
  - 타임아웃
  - 미처리 요청 개수 제한
  - circuit breaker pattern, 에러율의 임계치 초과시 그 이후 시도는 바로 실패 처리
    - `netflix Hystrix`, Polly(.net) 
- 불능 서비스 복구
  - 어떻게 복구할지는 상황에 따라 
  - 에러 반환하기
  - 미리 정해진 기본값이나 캐시된 응답 등 대체 값을 반한하기
 
 
#
#### 서비스 디스커버리 
REST API가 있는 어떤 서비스를 호출할 때, 그 서비스 인스턴스의 네트워크 위치를 알고 있어야 요청이 가능하다.  
클라우드 기반의 마이크로서비스 어플리케이션은 그 위치가 동적이라 식별하는 게 간단하지 않다.  
또한 서비스 인스턴스가 자동 확장 되고, 실패, 업그레이드 등 계속 달라지므로 서비스 디스커버리가 필요하다.  


서비스 인스턴스의 네트워크 위치를 DB화 한 서비스 레지스트리.  
서비스 인스턴스가 시작/종료될 때마다 서비스 레지스트리가 업데이트 된다.  


- 애플리케이션 수준 디스커버리 패턴
  - `Eureka`
  - 사용하는 언어에 맞는 서비스 디스커버리 라이브러리가 필요한 단점. 
- 플랫폼에 내장된 서비스 디스커버리 패턴
  - `도커`, `쿠버네티스` 등 최신 배포 플랫폼에는 대부분 서비스 레지스트리, 서비스 디스커버리 매커니즘이 탑재되어 있다.  
  - 쿠버네티스에 기반한 디스커버리는 오직 쿠버네티스로 배포한 서비스에만 적용되는 단점. 
  - 개발 언어 상관없이 모든 클라이언트/서비스에 적용 가능


#
#### 비동기 메시징 패턴
메시징은 서비스가 메시지를 서로 비동기적으로 주고받는 통신 방식이다.  
서비스 간 중개 역할을 하는 `메시지 브로커`를 사용하는데 서비스가 직접 서로 통신하는 `브로커리스` 아키텍처도 있다.

#
##### 메시징
메시지는 `header`, `body`로 구성된다.  
헤더는 송신된 데이터에 관한 메타데이터에 해당하는 키/값으로 구성.  
그 밖에도 송신자, 인프라에서 생성된 메시지 ID, 응답이 출력될 메시지 채널을 가리키는 반환 주소 등이 있다.  
본문은 실제로 송신할 텍스트 또는 이진 포맷의 데이터.  

- 메시지 종류
  - `문서`(document): 데이터만 포함된 제네릭한 메시지. 
  - `커맨드`: RPC 요청과 동등한 메시지. 
  - `이벤트`: 송신자에게 어떤 사건이 발생했음을 알리는 메시지. 대부분 Order, Customer 같은 도메인 객체의 상태 변화를 나타내는 도메인 이벤트


- 메시지 채널
  - 메시지를 채널을 통해 교환된다.  
  - 채널 종류
    - 점대점(`point to point`): 채널을 읽는 컨슈머 중 딱 하나만 지정하여 메시지를 전달. 예: `커맨드 메시지`
    - `publish/subscribe`: 같은 채널을 바라보는 모든 컨슈머에 메시지를 전달. 예: `이벤트 메시지`
    

#
#### 메시지 브로커
메시시 브로커는 모든 메시지가 지나가는 중간 지점이다.  
`송신자`가 메시지 브로커에 메시지를 쓰면 이를 `수신자`에게 전달한다.  
메시지 브로커의 가장 큰 장점은 송신자가 컨슈머의 네트워크 위치를 몰라도 된다는 것이다.  
또한 컨슈머가 메시지를 처리할 수 있을 때까지 버퍼링도 가능하다.    


- 많이 쓰는 오픈 소스 메시지 브로커는 아래와 같다. 
  - ActiveMQ
  - RabbitMQ
  - Apache Kafka    
- 클라우드 기반 메시징 서비스도 있다. 
  - AWS Kinesis
  - AWS SQS


- 선택할 때는 아래 항목을 잘 검토해야 한다. 
  - 언어 지원 여부
  - 메시징 표준 지원 여부
  - 메시지 순서 유지 여부
  - 전달 보장
  - 영속화
  - 내구성
  - 확장성
  - 지연 시간
  - 경쟁사의 컨슈머 지원 여부


- 구현방식이 다소 다르다
  - ActiveMQ 같은 JMS 메시지 브로커는 큐와 토픽
  - RabbitMQ 같은 AMQP 기반의 메시지 브로커는 익스체인지와 큐
  - 아파치 카프카는 토픽
  - AWS 키네시스는 스트럼
  - AWS SQS는 큐

AWS SQS는 `점대점` 채널만 지원하고 나머지는 `점대점`, `발행/구독` 채널 모두 지원한다.   


- 장점
  - 느슨한 결합
  - 메시지 버퍼링
  - 유연한 통신 (위에 기술한 상호 작용 스타일 모두 적용함)
- 단점
  - 성능 병목 가능성, 요즘 메시지 브로커는 대부분 확장이 잘 됨
  - 단일 장애점 가능성, 요즘 대부분 고가용성이 보장
  - 운영 복잡도 부가


#
#### 수신자 경합과 메시지 순서 유지  
예를 들어 동일한 점대점 채널을 읽는 서비스 인스턴스가 3대 있고, 송신자는 수문 생성됨, 주문 변경됨, 주문 취소됨 이벤트 메시지를 차례로 전송한다면  
동시 전달하면 될 것 같지만 네트워트 이슈나 GC 등 지연이 발생하고 순서가 어긋나면 시스템이 오작동 할 수 있다.  

그래서 아파치 카프카, 키네시스 등 요즘 메시지 브로커는 `샤딩`된 채널을 이용한다.  
- 각 샤드는 채널처럼 작동한다. 
- 송신자는 메시지 헤더에 샤드 키를 지정한다. 메시지 브로커는 샤드 키별로 메시지를 배정한다. 
- 메시징 브로커는 여러 수신자 인스턴스를 묶어 마치 동일한 논리 수신자처럼 취급한다. (아파치 카프카, 컨슈머 그룹)


# 
#### 중복 메시지 처리
중복 메시지 처리 문제도 중요하다.  
꼭 한 번만 전달하려면 그만큼 비싼 대가를 치러야 한다.  
중복 메시지 처리 방법은 두가지이다. 
- 멱등한(idempotent) 메시지 핸들러 작성
- 메시지를 추적하고 중복을 솎아 낸다. 


컨슈머가 메시지 ID를 이용하여 메시지 처리 여부를 추적하면 된다.  
이를테면 컨슈머가 소비하는 메시지 ID를 무조건 DB 테이블에 저장한다.  


#
#### 트랜잭셔널 메시징
DB 업데이트와 메시지 전송을 한 트랜잭션으로 묶지 않으면, DB 업데이트 후 메시지는 전송이 아직인 상태에서 서비스가 중단될 수 없으므로 문제가 된다.  
예전에는 DB와 메시지 브로커에 분산 트랜잭션을 적용했었으나, 요즘 메시지 브로커는 분산 트랜잭션을 지원하지 않는다.  
  

어플리케이션에서 메시지를 확실하게 발행하려면 어떻게 해야 하나?  
RDBMS 기반의 어플리케이션이라면 DB 테이블을 임시 메시지 큐로 사용하는 트랜잭셔널 아웃박스 패턴이 가장 알기 쉬운 방법이다.  


메시지를 DB에서 메시지 브로커로 옮기는 방법은 폴링 발행기 패턴과 `트랜잭션 로그 테일링` 패턴이 있다.    


`트랜잭션 로그 테일링`은 메시지 릴레이로 DB 트랜잭션 로그(커밋 로그)를 tailing하는 방법이다.  
어플리케이션에서 커밋된 업데이트는 각 DB의 트랜잭션 로그 항목으로 남는다.  
트랜잭션 로그 마이너(log miner)로 트랜잭션 로그를 읽어 변경분을 하나씩 메시지로 메시지 브로커에 발행하는 것이다.  


이 방식을 응용한 사례는 아래와 같다.  
- Debezium
- LinkedIn Databus
- DynamoDB Streams
- `Eventuate Tram`


해당 도서의 저자는 마지막 Eventuate Tram을 개발했다.  

#
#### 비동기 메시징으로 가용성 개선
REST는 대중적인 IPC이지만 블로킹이므로 가용성은 그만큼 저하된다.  
따라서 가용성을 최대화하려면 동기 통신은 최소화 해야 한다.  
서비스에 동기 API가 있는 경우는 `데이터 복제`를 이용하는 것도 좋은 방법이다.  


가령 소비자/음식점 서비스가 소유한 데이터 레플리카를 주문 서비스가 이미 갖고 있다면 굳이 상호 작용할 필요가 없다.  
소비자/음식점 서비스의 각자 데이터가 변경될 떄마다 이벤트를 발행하고, 주문 서비스는 이 이벤트를 구독하여 레플리카를 업데이트 하는 것이다.  
물론 대용량 레플리카를 만드는것은 대단히 비효율적이다.   


한가지 해결 방법은 서비스가 요청 처리 중에 다른 서비스와 동기적 상호 작용은 하지 않고 다른 서비스에 메시지를 비동기 하는 방법이다.  
(일단 클라이어트에 보내 놓고 비동기 통신하는 방법)    
다음장에서 `사가`를 이용하여 서비스를 느슨하게 결합한다.  



